<?php

namespace Vladitot\Architect\YamlComponents;

use Vladitot\Architect\AbstractGenerator;
use Vladitot\Architect\NamespaceAndPathGeneratorYaml;
use Vladitot\Architect\Yaml\Laravel\Model;
use Vladitot\Architect\Yaml\Laravel\ModelRelation;
use Vladitot\Architect\Yaml\Module;
use Nette\PhpGenerator\ClassLike;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\TraitUse;

class ModelGenerator extends AbstractGenerator
{
    private function createModelName(string $title) {
        $title = str_replace('.','',
            str_replace(' ', '', ucfirst($title))
        );
        return $title;
    }

    private function fillModelClass(ClassType|ClassLike $class, Model $model, string $moduleTitle, array $modelRelations): ClassLike|ClassType
    {
        $class = $this->fillModelRelations($class, $model, $modelRelations);
        $this->setTableName($class, $model);
        $this->setConnection($class, $model, $moduleTitle);
        return $class;
    }

    private function setTableName(ClassType|ClassLike $class, Model $model): void
    {
        if ($class->hasProperty('table')) {
            $class->removeProperty('table');
        }
        $class->addProperty('table')
            ->setValue(NamespaceAndPathGeneratorYaml::generateTableNameFromModelName($model->title))
            ->setProtected();
    }
    private function setConnection(ClassType|ClassLike $class, Model $model, string $moduleTitle): void
    {
        if ($class->hasProperty('connection')) {
            $class->removeProperty('connection');
        }
        $class->addProperty('connection')
            ->setValue('pgsql-'.NamespaceAndPathGeneratorYaml::convertStringToSnakeCase($moduleTitle))
            ->setProtected();
    }

    public function generate(Module $module)
    {


        $models = $module->models;

        foreach ($models as $model) {
            $this->generateOneModel($model, $module->model_relations, $module->title);
        }

    }

    public function generateOneModel(Model $model, array $modelRelations, string $moduleTitle) {

        $filePathOfModel = NamespaceAndPathGeneratorYaml::generateModelPath(
            $moduleTitle,
            $model->title,
        );
        $namespaceOfModel = NamespaceAndPathGeneratorYaml::generateModelNamespace(
            $moduleTitle
        );
        $modelAlreadyExists = file_exists($filePathOfModel);

        $namespace = new PhpNamespace($namespaceOfModel);
        if ($modelAlreadyExists) {
            $class = \Nette\PhpGenerator\ClassType::fromCode(file_get_contents($filePathOfModel));
        } else {
            $class = new ClassType($this->createModelName($model->title));
        }

        $class->setComment('@architect '."\n".$model->comment ?? '');

        $class->setExtends(\Illuminate\Database\Eloquent\Model::class);
        $namespace->addUse(\Illuminate\Database\Eloquent\Model::class);
        try {
            $class->addMember(new TraitUse(\Illuminate\Database\Eloquent\Factories\HasFactory::class));
        } catch (\Throwable $e) {
            if (!$e->getMessage()=="Cannot add member 'Illuminate\Database\Eloquent\Factories\HasFactory', because it already exists.") {
                throw $e;
            }
        }


        $namespace->add($class);

        $this->fillModelClass($class, $model, $moduleTitle, $modelRelations);

        $file = new \Nette\PhpGenerator\PhpFile;
        $file->addComment('This file is generated by architect.');
        $file->addNamespace($namespace);

        @mkdir(dirname($filePathOfModel), recursive: true);
        file_put_contents($filePathOfModel, $file);
    }

    /**
     * @param ClassType|ClassLike $class
     * @param Model $model
     * @param array|ModelRelation[] $modelRelations
     * @return ClassType|ClassLike
     */
    private function fillModelRelations(ClassType|ClassLike $class, Model $model, array $modelRelations): ClassType|ClassLike
    {

        //lets check methods are present, and mark them as deprecated

        foreach ($class->getMethods() as $method) {
            $body = $method->getBody();

            if (str_contains($body,'return $this->hasMany')
                || str_contains($body, 'return $this->hasOne')
                || str_contains($body, 'return $this->belongsTo')
                || str_contains($body, 'return $this->belongsToMany')
            ) {
                $method->addComment('@deprecated');
            }
        }

        // firstly lets resolve "left". So we use direct relations
        foreach ($modelRelations as $relation) {
            if ($relation->left_model_name == $model->title) {
                $class->removeMethod($relation->relation_left_title);
                $method = $class->addMethod($relation->relation_left_title);
                $method->addComment('Method is auto-generated by architect');
                $method->setComment(str_replace('@deprecated', '', $method->getComment()));
                if ($relation->relation_type == 'HasMany') {
                    $method->setBody('return $this->hasMany(' . $relation->right_model_name . '::class);');
                    continue;
                }
                if ($relation->relation_type == 'HasOne') {
                    $method->setBody('return $this->hasOne(' . $relation->right_model_name . '::class);');
                    continue;
                }

                if ($relation->relation_type == 'BelongsTo') {
                    $method->setBody('return $this->belongsTo(' . $relation->right_model_name . '::class);');
                    continue;
                }

                if ($relation->relation_type == 'BelongsToMany') {
                    $method->setBody('return $this->belongsToMany(' . $relation->right_model_name . '::class);');
                    continue;
                }
            }
        }

        // firstly lets resolve "right". So we use inDirect relations

        foreach ($modelRelations as $relation) {
            if ($relation->right_model_name == $model->title) {
                $class->removeMethod($relation->relation_right_title);
                $method = $class->addMethod($relation->relation_right_title);
                $method->addComment('Method is auto-generated by architect');
                if ($relation->relation_type == 'HasMany') {
                    $method->setBody('return $this->belongsTo(' . $relation->left_model_name . '::class);');
                    continue;
                }
                if ($relation->relation_type == 'HasOne') {
                    $method->setBody('return $this->hasOne(' . $relation->left_model_name . '::class);');
                    continue;
                }

                if ($relation->relation_type == 'BelongsTo') {
                    $method->setBody('return $this->hasMany(' . $relation->left_model_name . '::class);');
                    continue;
                }

                if ($relation->relation_type == 'BelongsToMany') {
                    $method->setBody('return $this->belongsToMany(' . $relation->left_model_name . '::class);');
                    continue;
                }
            }
        }
        return $class;
    }
}
